<!doctype html>

<title>CodeMirror: Scala mode</title>
<meta charset="utf-8"/>
<link rel=stylesheet href="../../doc/docs.css">

<link rel="stylesheet" href="../../lib/codemirror.css">
<link rel="stylesheet" href="../../theme/ambiance.css">
<script src="../../lib/codemirror.js"></script>
<script src="../../addon/edit/matchbrackets.js"></script>
<script src="clike.js"></script>
<div id=nav>
  <a href="http://codemirror.net"><img id=logo src="../../doc/logo.png"></a>

  <ul>
    <li><a href="../../index.html">Home</a>
    <li><a href="../../doc/manual.html">Manual</a>
    <li><a href="https://github.com/marijnh/codemirror">Code</a>
  </ul>
  <ul>
    <li><a href="../index.html">Language modes</a>
    <li><a class=active href="#">Scala</a>
  </ul>
</div>

<article>
<h2>Scala mode</h2>
<form>
<textarea id="code" name="code">

  /*                     __                                              ***REMOVED***\
 ***REMOVED****     ________ ___   / /  ___     Scala API                           ***REMOVED****
 ***REMOVED****    / __/ __// _ | / /  / _ |    (c) 2003-2011, LAMP/EPFL            ***REMOVED****
 ***REMOVED****  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/              ***REMOVED****
 ***REMOVED**** /____/\___/_/ |_/____/_/ | |                                        ***REMOVED****
 ***REMOVED****                          |/                                         ***REMOVED****
  \*                                                                    ***REMOVED*****REMOVED***

  package scala.collection

  import generic._
  import mutable.{ Builder, ListBuffer }
  import annotation.{tailrec, migration, bridge}
  import annotation.unchecked.{ uncheckedVariance => uV }
  import parallel.ParIterable

 ***REMOVED*****REMOVED*** A template trait for traversable collections of type `Traversable[A]`.
  ***REMOVED***  
  ***REMOVED***  $traversableInfo
  ***REMOVED***  @define mutability
  ***REMOVED***  @define traversableInfo
  ***REMOVED***  This is a base trait of all kinds of $mutability Scala collections. It
  ***REMOVED***  implements the behavior common to all collections, in terms of a method
  ***REMOVED***  `foreach` with signature:
  ***REMOVED*** {{{
  ***REMOVED***     def foreach[U](f: Elem => U): Unit
  ***REMOVED*** }}}
  ***REMOVED***  Collection classes mixing in this trait provide a concrete 
  ***REMOVED***  `foreach` method which traverses all the
  ***REMOVED***  elements contained in the collection, applying a given function to each.
  ***REMOVED***  They also need to provide a method `newBuilder`
  ***REMOVED***  which creates a builder for collections of the same kind.
  ***REMOVED***  
  ***REMOVED***  A traversable class might or might not have two properties: strictness
  ***REMOVED***  and orderedness. Neither is represented as a type.
  ***REMOVED***  
  ***REMOVED***  The instances of a strict collection class have all their elements
  ***REMOVED***  computed before they can be used as values. By contrast, instances of
  ***REMOVED***  a non-strict collection class may defer computation of some of their
  ***REMOVED***  elements until after the instance is available as a value.
  ***REMOVED***  A typical example of a non-strict collection class is a
  ***REMOVED***  <a href="../immutable/Stream.html" target="ContentFrame">
  ***REMOVED***  `scala.collection.immutable.Stream`</a>.
  ***REMOVED***  A more general class of examples are `TraversableViews`.
  ***REMOVED***  
  ***REMOVED***  If a collection is an instance of an ordered collection class, traversing
  ***REMOVED***  its elements with `foreach` will always visit elements in the
  ***REMOVED***  same order, even for different runs of the program. If the class is not
  ***REMOVED***  ordered, `foreach` can visit elements in different orders for
  ***REMOVED***  different runs (but it will keep the same order in the same run).'
  ***REMOVED*** 
  ***REMOVED***  A typical example of a collection class which is not ordered is a
  ***REMOVED***  `HashMap` of objects. The traversal order for hash maps will
  ***REMOVED***  depend on the hash codes of its elements, and these hash codes might
  ***REMOVED***  differ from one run to the next. By contrast, a `LinkedHashMap`
  ***REMOVED***  is ordered because it's `foreach` method visits elements in the
  ***REMOVED***  order they were inserted into the `HashMap`.
  ***REMOVED***
  ***REMOVED***  @author Martin Odersky
  ***REMOVED***  @version 2.8
  ***REMOVED***  @since   2.8
  ***REMOVED***  @tparam A    the element type of the collection
  ***REMOVED***  @tparam Repr the type of the actual collection containing the elements.
  ***REMOVED***
  ***REMOVED***  @define Coll Traversable
  ***REMOVED***  @define coll traversable collection
 ***REMOVED*****REMOVED***
  trait TraversableLike[+A, +Repr] extends HasNewBuilder[A, Repr] 
                                      with FilterMonadic[A, Repr]
                                      with TraversableOnce[A]
                                      with GenTraversableLike[A, Repr]
                                      with Parallelizable[A, ParIterable[A]]
  {
    self =>

    import Traversable.breaks._

   ***REMOVED*****REMOVED*** The type implementing this traversable***REMOVED***
    protected type Self = Repr

   ***REMOVED*****REMOVED*** The collection of type $coll underlying this `TraversableLike` object.
    ***REMOVED***  By default this is implemented as the `TraversableLike` object itself,
    ***REMOVED***  but this can be overridden.
   ***REMOVED*****REMOVED***
    def repr: Repr = this.asInstanceOf[Repr]

   ***REMOVED*****REMOVED*** The underlying collection seen as an instance of `$Coll`.
    ***REMOVED***  By default this is implemented as the current collection object itself,
    ***REMOVED***  but this can be overridden.
   ***REMOVED*****REMOVED***
    protected[this] def thisCollection: Traversable[A] = this.asInstanceOf[Traversable[A]]

   ***REMOVED*****REMOVED*** A conversion from collections of type `Repr` to `$Coll` objects.
    ***REMOVED***  By default this is implemented as just a cast, but this can be overridden.
   ***REMOVED*****REMOVED***
    protected[this] def toCollection(repr: Repr): Traversable[A] = repr.asInstanceOf[Traversable[A]]

   ***REMOVED*****REMOVED*** Creates a new builder for this collection type.
   ***REMOVED*****REMOVED***
    protected[this] def newBuilder: Builder[A, Repr]

    protected[this] def parCombiner = ParIterable.newCombiner[A]

   ***REMOVED*****REMOVED*** Applies a function `f` to all elements of this $coll.
    ***REMOVED***  
    ***REMOVED***    Note: this method underlies the implementation of most other bulk operations.
    ***REMOVED***    It's important to implement this method in an efficient way.
    ***REMOVED***  
    ***REMOVED***
    ***REMOVED***  @param  f   the function that is applied for its side-effect to every element.
    ***REMOVED***              The result of function `f` is discarded.
    ***REMOVED***              
    ***REMOVED***  @tparam  U  the type parameter describing the result of function `f`. 
    ***REMOVED***              This result will always be ignored. Typically `U` is `Unit`,
    ***REMOVED***              but this is not necessary.
    ***REMOVED***
    ***REMOVED***  @usecase def foreach(f: A => Unit): Unit
   ***REMOVED*****REMOVED***
    def foreach[U](f: A => U): Unit

   ***REMOVED*****REMOVED*** Tests whether this $coll is empty.
    ***REMOVED***
    ***REMOVED***  @return    `true` if the $coll contain no elements, `false` otherwise.
   ***REMOVED*****REMOVED***
    def isEmpty: Boolean = {
      var result = true
      breakable {
        for (x <- this) {
          result = false
          break
        }
      }
      result
    }

   ***REMOVED*****REMOVED*** Tests whether this $coll is known to have a finite size.
    ***REMOVED***  All strict collections are known to have finite size. For a non-strict collection
    ***REMOVED***  such as `Stream`, the predicate returns `true` if all elements have been computed.
    ***REMOVED***  It returns `false` if the stream is not yet evaluated to the end.
    ***REMOVED***
    ***REMOVED***  Note: many collection methods will not work on collections of infinite sizes. 
    ***REMOVED***
    ***REMOVED***  @return  `true` if this collection is known to have finite size, `false` otherwise.
   ***REMOVED*****REMOVED***
    def hasDefiniteSize = true

    def ++[B >: A, That](that: GenTraversableOnce[B])(implicit bf: CanBuildFrom[Repr, B, That]): That = {
      val b = bf(repr)
      if (that.isInstanceOf[IndexedSeqLike[_, _]]) b.sizeHint(this, that.seq.size)
      b ++= thisCollection
      b ++= that.seq
      b.result
    }

    @bridge
    def ++[B >: A, That](that: TraversableOnce[B])(implicit bf: CanBuildFrom[Repr, B, That]): That =
      ++(that: GenTraversableOnce[B])(bf)

   ***REMOVED*****REMOVED*** Concatenates this $coll with the elements of a traversable collection.
    ***REMOVED***  It differs from ++ in that the right operand determines the type of the
    ***REMOVED***  resulting collection rather than the left one.
    ***REMOVED*** 
    ***REMOVED***  @param that   the traversable to append.
    ***REMOVED***  @tparam B     the element type of the returned collection. 
    ***REMOVED***  @tparam That  $thatinfo
    ***REMOVED***  @param bf     $bfinfo
    ***REMOVED***  @return       a new collection of type `That` which contains all elements
    ***REMOVED***                of this $coll followed by all elements of `that`.
    ***REMOVED*** 
    ***REMOVED***  @usecase def ++:[B](that: TraversableOnce[B]): $Coll[B]
    ***REMOVED***  
    ***REMOVED***  @return       a new $coll which contains all elements of this $coll
    ***REMOVED***                followed by all elements of `that`.
   ***REMOVED*****REMOVED***
    def ++:[B >: A, That](that: TraversableOnce[B])(implicit bf: CanBuildFrom[Repr, B, That]): That = {
      val b = bf(repr)
      if (that.isInstanceOf[IndexedSeqLike[_, _]]) b.sizeHint(this, that.size)
      b ++= that
      b ++= thisCollection
      b.result
    }

   ***REMOVED*****REMOVED*** This overload exists because: for the implementation of ++: we should reuse
    ***REMOVED***  that of ++ because many collections override it with more efficient versions.
    ***REMOVED***  Since TraversableOnce has no '++' method, we have to implement that directly,
    ***REMOVED***  but Traversable and down can use the overload.
   ***REMOVED*****REMOVED***
    def ++:[B >: A, That](that: Traversable[B])(implicit bf: CanBuildFrom[Repr, B, That]): That =
      (that ++ seq)(breakOut)

    def map[B, That](f: A => B)(implicit bf: CanBuildFrom[Repr, B, That]): That = {
      val b = bf(repr)
      b.sizeHint(this) 
      for (x <- this) b += f(x)
      b.result
    }

    def flatMap[B, That](f: A => GenTraversableOnce[B])(implicit bf: CanBuildFrom[Repr, B, That]): That = {
      val b = bf(repr)
      for (x <- this) b ++= f(x).seq
      b.result
    }

   ***REMOVED*****REMOVED*** Selects all elements of this $coll which satisfy a predicate.
    ***REMOVED***
    ***REMOVED***  @param p     the predicate used to test elements.
    ***REMOVED***  @return      a new $coll consisting of all elements of this $coll that satisfy the given
    ***REMOVED***               predicate `p`. The order of the elements is preserved.
   ***REMOVED*****REMOVED***
    def filter(p: A => Boolean): Repr = {
      val b = newBuilder
      for (x <- this) 
        if (p(x)) b += x
      b.result
    }

   ***REMOVED*****REMOVED*** Selects all elements of this $coll which do not satisfy a predicate.
    ***REMOVED***
    ***REMOVED***  @param p     the predicate used to test elements.
    ***REMOVED***  @return      a new $coll consisting of all elements of this $coll that do not satisfy the given
    ***REMOVED***               predicate `p`. The order of the elements is preserved.
   ***REMOVED*****REMOVED***
    def filterNot(p: A => Boolean): Repr = filter(!p(_))

    def collect[B, That](pf: PartialFunction[A, B])(implicit bf: CanBuildFrom[Repr, B, That]): That = {
      val b = bf(repr)
      for (x <- this) if (pf.isDefinedAt(x)) b += pf(x)
      b.result
    }

   ***REMOVED*****REMOVED*** Builds a new collection by applying an option-valued function to all
    ***REMOVED***  elements of this $coll on which the function is defined.
    ***REMOVED***
    ***REMOVED***  @param f      the option-valued function which filters and maps the $coll.
    ***REMOVED***  @tparam B     the element type of the returned collection.
    ***REMOVED***  @tparam That  $thatinfo
    ***REMOVED***  @param bf     $bfinfo
    ***REMOVED***  @return       a new collection of type `That` resulting from applying the option-valued function
    ***REMOVED***                `f` to each element and collecting all defined results.
    ***REMOVED***                The order of the elements is preserved.
    ***REMOVED***
    ***REMOVED***  @usecase def filterMap[B](f: A => Option[B]): $Coll[B]
    ***REMOVED***  
    ***REMOVED***  @param pf     the partial function which filters and maps the $coll.
    ***REMOVED***  @return       a new $coll resulting from applying the given option-valued function
    ***REMOVED***                `f` to each element and collecting all defined results.
    ***REMOVED***                The order of the elements is preserved.
    def filterMap[B, That](f: A => Option[B])(implicit bf: CanBuildFrom[Repr, B, That]): That = {
      val b = bf(repr)
      for (x <- this) 
        f(x) match {
          case Some(y) => b += y
          case _ =>
        }
      b.result
    }
   ***REMOVED*****REMOVED***

   ***REMOVED*****REMOVED*** Partitions this $coll in two ${coll}s according to a predicate.
    ***REMOVED***
    ***REMOVED***  @param p the predicate on which to partition.
    ***REMOVED***  @return  a pair of ${coll}s: the first $coll consists of all elements that 
    ***REMOVED***           satisfy the predicate `p` and the second $coll consists of all elements
    ***REMOVED***           that don't. The relative order of the elements in the resulting ${coll}s
    ***REMOVED***           is the same as in the original $coll.
   ***REMOVED*****REMOVED***
    def partition(p: A => Boolean): (Repr, Repr) = {
      val l, r = newBuilder
      for (x <- this) (if (p(x)) l else r) += x
      (l.result, r.result)
    }

    def groupBy[K](f: A => K): immutable.Map[K, Repr] = {
      val m = mutable.Map.empty[K, Builder[A, Repr]]
      for (elem <- this) {
        val key = f(elem)
        val bldr = m.getOrElseUpdate(key, newBuilder)
        bldr += elem
      }
      val b = immutable.Map.newBuilder[K, Repr]
      for ((k, v) <- m)
        b += ((k, v.result))

      b.result
    }

   ***REMOVED*****REMOVED*** Tests whether a predicate holds for all elements of this $coll.
    ***REMOVED***
    ***REMOVED***  $mayNotTerminateInf
    ***REMOVED***
    ***REMOVED***  @param   p     the predicate used to test elements.
    ***REMOVED***  @return        `true` if the given predicate `p` holds for all elements
    ***REMOVED***                 of this $coll, otherwise `false`.
   ***REMOVED*****REMOVED***
    def forall(p: A => Boolean): Boolean = {
      var result = true
      breakable {
        for (x <- this)
          if (!p(x)) { result = false; break }
      }
      result
    }

   ***REMOVED*****REMOVED*** Tests whether a predicate holds for some of the elements of this $coll.
    ***REMOVED***
    ***REMOVED***  $mayNotTerminateInf
    ***REMOVED***
    ***REMOVED***  @param   p     the predicate used to test elements.
    ***REMOVED***  @return        `true` if the given predicate `p` holds for some of the
    ***REMOVED***                 elements of this $coll, otherwise `false`.
   ***REMOVED*****REMOVED***
    def exists(p: A => Boolean): Boolean = {
      var result = false
      breakable {
        for (x <- this)
          if (p(x)) { result = true; break }
      }
      result
    }

   ***REMOVED*****REMOVED*** Finds the first element of the $coll satisfying a predicate, if any.
    ***REMOVED*** 
    ***REMOVED***  $mayNotTerminateInf
    ***REMOVED***  $orderDependent
    ***REMOVED***
    ***REMOVED***  @param p    the predicate used to test elements.
    ***REMOVED***  @return     an option value containing the first element in the $coll
    ***REMOVED***              that satisfies `p`, or `None` if none exists.
   ***REMOVED*****REMOVED***
    def find(p: A => Boolean): Option[A] = {
      var result: Option[A] = None
      breakable {
        for (x <- this)
          if (p(x)) { result = Some(x); break }
      }
      result
    }

    def scan[B >: A, That](z: B)(op: (B, B) => B)(implicit cbf: CanBuildFrom[Repr, B, That]): That = scanLeft(z)(op)

    def scanLeft[B, That](z: B)(op: (B, A) => B)(implicit bf: CanBuildFrom[Repr, B, That]): That = {
      val b = bf(repr)
      b.sizeHint(this, 1)
      var acc = z
      b += acc
      for (x <- this) { acc = op(acc, x); b += acc }
      b.result
    }

    @migration(2, 9,
      "This scanRight definition has changed in 2.9.\n" +
      "The previous behavior can be reproduced with scanRight.reverse."
    )
    def scanRight[B, That](z: B)(op: (A, B) => B)(implicit bf: CanBuildFrom[Repr, B, That]): That = {
      var scanned = List(z)
      var acc = z
      for (x <- reversed) {
        acc = op(x, acc)
        scanned ::= acc
      }
      val b = bf(repr)
      for (elem <- scanned) b += elem
      b.result
    }

   ***REMOVED*****REMOVED*** Selects the first element of this $coll.
    ***REMOVED***  $orderDependent
    ***REMOVED***  @return  the first element of this $coll.
    ***REMOVED***  @throws `NoSuchElementException` if the $coll is empty.
   ***REMOVED*****REMOVED***
    def head: A = {
      var result: () => A = () => throw new NoSuchElementException
      breakable {
        for (x <- this) {
          result = () => x
          break
        }
      }
      result()
    }

   ***REMOVED*****REMOVED*** Optionally selects the first element.
    ***REMOVED***  $orderDependent
    ***REMOVED***  @return  the first element of this $coll if it is nonempty, `None` if it is empty.
   ***REMOVED*****REMOVED***
    def headOption: Option[A] = if (isEmpty) None else Some(head)

   ***REMOVED*****REMOVED*** Selects all elements except the first.
    ***REMOVED***  $orderDependent
    ***REMOVED***  @return  a $coll consisting of all elements of this $coll
    ***REMOVED***           except the first one.
    ***REMOVED***  @throws `UnsupportedOperationException` if the $coll is empty.
   ***REMOVED*****REMOVED*** 
    override def tail: Repr = {
      if (isEmpty) throw new UnsupportedOperationException("empty.tail")
      drop(1)
    }

   ***REMOVED*****REMOVED*** Selects the last element.
     ***REMOVED*** $orderDependent
     ***REMOVED*** @return The last element of this $coll.
     ***REMOVED*** @throws NoSuchElementException If the $coll is empty.
    ***REMOVED*****REMOVED***
    def last: A = {
      var lst = head
      for (x <- this)
        lst = x
      lst
    }

   ***REMOVED*****REMOVED*** Optionally selects the last element.
    ***REMOVED***  $orderDependent
    ***REMOVED***  @return  the last element of this $coll$ if it is nonempty, `None` if it is empty.
   ***REMOVED*****REMOVED***
    def lastOption: Option[A] = if (isEmpty) None else Some(last)

   ***REMOVED*****REMOVED*** Selects all elements except the last.
    ***REMOVED***  $orderDependent
    ***REMOVED***  @return  a $coll consisting of all elements of this $coll
    ***REMOVED***           except the last one.
    ***REMOVED***  @throws `UnsupportedOperationException` if the $coll is empty.
   ***REMOVED*****REMOVED***
    def init: Repr = {
      if (isEmpty) throw new UnsupportedOperationException("empty.init")
      var lst = head
      var follow = false
      val b = newBuilder
      b.sizeHint(this, -1)
      for (x <- this.seq) {
        if (follow) b += lst
        else follow = true
        lst = x
      }
      b.result
    }

    def take(n: Int): Repr = slice(0, n)

    def drop(n: Int): Repr = 
      if (n <= 0) {
        val b = newBuilder
        b.sizeHint(this)
        b ++= thisCollection result
      }
      else sliceWithKnownDelta(n, Int.MaxValue, -n)

    def slice(from: Int, until: Int): Repr = sliceWithKnownBound(math.max(from, 0), until)

    // Precondition: from >= 0, until > 0, builder already configured for building.
    private[this] def sliceInternal(from: Int, until: Int, b: Builder[A, Repr]): Repr = {
      var i = 0
      breakable {
        for (x <- this.seq) {
          if (i >= from) b += x
          i += 1
          if (i >= until) break
        }
      }
      b.result
    }
    // Precondition: from >= 0
    private[scala] def sliceWithKnownDelta(from: Int, until: Int, delta: Int): Repr = {
      val b = newBuilder
      if (until <= from) b.result
      else {
        b.sizeHint(this, delta)
        sliceInternal(from, until, b)
      }
    }
    // Precondition: from >= 0
    private[scala] def sliceWithKnownBound(from: Int, until: Int): Repr = {
      val b = newBuilder
      if (until <= from) b.result
      else {
        b.sizeHintBounded(until - from, this)      
        sliceInternal(from, until, b)
      }
    }

    def takeWhile(p: A => Boolean): Repr = {
      val b = newBuilder
      breakable {
        for (x <- this) {
          if (!p(x)) break
          b += x
        }
      }
      b.result
    }

    def dropWhile(p: A => Boolean): Repr = {
      val b = newBuilder
      var go = false
      for (x <- this) {
        if (!p(x)) go = true
        if (go) b += x
      }
      b.result
    }

    def span(p: A => Boolean): (Repr, Repr) = {
      val l, r = newBuilder
      var toLeft = true
      for (x <- this) {
        toLeft = toLeft && p(x)
        (if (toLeft) l else r) += x
      }
      (l.result, r.result)
    }

    def splitAt(n: Int): (Repr, Repr) = {
      val l, r = newBuilder
      l.sizeHintBounded(n, this)
      if (n >= 0) r.sizeHint(this, -n)
      var i = 0
      for (x <- this) {
        (if (i < n) l else r) += x
        i += 1
      }
      (l.result, r.result)
    }

   ***REMOVED*****REMOVED*** Iterates over the tails of this $coll. The first value will be this
    ***REMOVED***  $coll and the final one will be an empty $coll, with the intervening
    ***REMOVED***  values the results of successive applications of `tail`.
    ***REMOVED***
    ***REMOVED***  @return   an iterator over all the tails of this $coll
    ***REMOVED***  @example  `List(1,2,3).tails = Iterator(List(1,2,3), List(2,3), List(3), Nil)`
   ***REMOVED*****REMOVED***  
    def tails: Iterator[Repr] = iterateUntilEmpty(_.tail)

   ***REMOVED*****REMOVED*** Iterates over the inits of this $coll. The first value will be this
    ***REMOVED***  $coll and the final one will be an empty $coll, with the intervening
    ***REMOVED***  values the results of successive applications of `init`.
    ***REMOVED***
    ***REMOVED***  @return  an iterator over all the inits of this $coll
    ***REMOVED***  @example  `List(1,2,3).inits = Iterator(List(1,2,3), List(1,2), List(1), Nil)`
   ***REMOVED*****REMOVED***
    def inits: Iterator[Repr] = iterateUntilEmpty(_.init)

   ***REMOVED*****REMOVED*** Copies elements of this $coll to an array.
    ***REMOVED***  Fills the given array `xs` with at most `len` elements of
    ***REMOVED***  this $coll, starting at position `start`.
    ***REMOVED***  Copying will stop once either the end of the current $coll is reached,
    ***REMOVED***  or the end of the array is reached, or `len` elements have been copied.
    ***REMOVED***
    ***REMOVED***  $willNotTerminateInf
    ***REMOVED*** 
    ***REMOVED***  @param  xs     the array to fill.
    ***REMOVED***  @param  start  the starting index.
    ***REMOVED***  @param  len    the maximal number of elements to copy.
    ***REMOVED***  @tparam B      the type of the elements of the array. 
    ***REMOVED*** 
    ***REMOVED***
    ***REMOVED***  @usecase def copyToArray(xs: Array[A], start: Int, len: Int): Unit
   ***REMOVED*****REMOVED***
    def copyToArray[B >: A](xs: Array[B], start: Int, len: Int) {
      var i = start
      val end = (start + len) min xs.length
      breakable {
        for (x <- this) {
          if (i >= end) break
          xs(i) = x
          i += 1
        }
      }
    }

    def toTraversable: Traversable[A] = thisCollection
    def toIterator: Iterator[A] = toStream.iterator
    def toStream: Stream[A] = toBuffer.toStream

   ***REMOVED*****REMOVED*** Converts this $coll to a string.
    ***REMOVED***
    ***REMOVED***  @return   a string representation of this collection. By default this
    ***REMOVED***            string consists of the `stringPrefix` of this $coll,
    ***REMOVED***            followed by all elements separated by commas and enclosed in parentheses.
   ***REMOVED*****REMOVED***
    override def toString = mkString(stringPrefix + "(", ", ", ")")

   ***REMOVED*****REMOVED*** Defines the prefix of this object's `toString` representation.
    ***REMOVED***
    ***REMOVED***  @return  a string representation which starts the result of `toString`
    ***REMOVED***           applied to this $coll. By default the string prefix is the
    ***REMOVED***           simple name of the collection class $coll.
   ***REMOVED*****REMOVED***
    def stringPrefix : String = {
      var string = repr.asInstanceOf[AnyRef].getClass.getName
      val idx1 = string.lastIndexOf('.' : Int)
      if (idx1 != -1) string = string.substring(idx1 + 1)
      val idx2 = string.indexOf('$')
      if (idx2 != -1) string = string.substring(0, idx2)
      string
    }

   ***REMOVED*****REMOVED*** Creates a non-strict view of this $coll.
    ***REMOVED*** 
    ***REMOVED***  @return a non-strict view of this $coll.
   ***REMOVED*****REMOVED***
    def view = new TraversableView[A, Repr] {
      protected lazy val underlying = self.repr
      override def foreach[U](f: A => U) = self foreach f
    }

   ***REMOVED*****REMOVED*** Creates a non-strict view of a slice of this $coll.
    ***REMOVED***
    ***REMOVED***  Note: the difference between `view` and `slice` is that `view` produces
    ***REMOVED***        a view of the current $coll, whereas `slice` produces a new $coll.
    ***REMOVED*** 
    ***REMOVED***  Note: `view(from, to)` is equivalent to `view.slice(from, to)`
    ***REMOVED***  $orderDependent
    ***REMOVED*** 
    ***REMOVED***  @param from   the index of the first element of the view
    ***REMOVED***  @param until  the index of the element following the view
    ***REMOVED***  @return a non-strict view of a slice of this $coll, starting at index `from`
    ***REMOVED***  and extending up to (but not including) index `until`.
   ***REMOVED*****REMOVED***
    def view(from: Int, until: Int): TraversableView[A, Repr] = view.slice(from, until)

   ***REMOVED*****REMOVED*** Creates a non-strict filter of this $coll.
    ***REMOVED***
    ***REMOVED***  Note: the difference between `c filter p` and `c withFilter p` is that
    ***REMOVED***        the former creates a new collection, whereas the latter only
    ***REMOVED***        restricts the domain of subsequent `map`, `flatMap`, `foreach`,
    ***REMOVED***        and `withFilter` operations.
    ***REMOVED***  $orderDependent
    ***REMOVED*** 
    ***REMOVED***  @param p   the predicate used to test elements.
    ***REMOVED***  @return    an object of class `WithFilter`, which supports
    ***REMOVED***             `map`, `flatMap`, `foreach`, and `withFilter` operations.
    ***REMOVED***             All these operations apply to those elements of this $coll which
    ***REMOVED***             satisfy the predicate `p`.
   ***REMOVED*****REMOVED***
    def withFilter(p: A => Boolean): FilterMonadic[A, Repr] = new WithFilter(p)

   ***REMOVED*****REMOVED*** A class supporting filtered operations. Instances of this class are
    ***REMOVED***  returned by method `withFilter`.
   ***REMOVED*****REMOVED***
    class WithFilter(p: A => Boolean) extends FilterMonadic[A, Repr] {

     ***REMOVED*****REMOVED*** Builds a new collection by applying a function to all elements of the
      ***REMOVED***  outer $coll containing this `WithFilter` instance that satisfy predicate `p`.
      ***REMOVED***
      ***REMOVED***  @param f      the function to apply to each element.
      ***REMOVED***  @tparam B     the element type of the returned collection.
      ***REMOVED***  @tparam That  $thatinfo
      ***REMOVED***  @param bf     $bfinfo
      ***REMOVED***  @return       a new collection of type `That` resulting from applying
      ***REMOVED***                the given function `f` to each element of the outer $coll
      ***REMOVED***                that satisfies predicate `p` and collecting the results.
      ***REMOVED***
      ***REMOVED***  @usecase def map[B](f: A => B): $Coll[B] 
      ***REMOVED***  
      ***REMOVED***  @return       a new $coll resulting from applying the given function
      ***REMOVED***                `f` to each element of the outer $coll that satisfies
      ***REMOVED***                predicate `p` and collecting the results.
     ***REMOVED*****REMOVED***
      def map[B, That](f: A => B)(implicit bf: CanBuildFrom[Repr, B, That]): That = {
        val b = bf(repr)
        for (x <- self) 
          if (p(x)) b += f(x)
        b.result
      }

     ***REMOVED*****REMOVED*** Builds a new collection by applying a function to all elements of the
      ***REMOVED***  outer $coll containing this `WithFilter` instance that satisfy
      ***REMOVED***  predicate `p` and concatenating the results. 
      ***REMOVED***
      ***REMOVED***  @param f      the function to apply to each element.
      ***REMOVED***  @tparam B     the element type of the returned collection.
      ***REMOVED***  @tparam That  $thatinfo
      ***REMOVED***  @param bf     $bfinfo
      ***REMOVED***  @return       a new collection of type `That` resulting from applying
      ***REMOVED***                the given collection-valued function `f` to each element
      ***REMOVED***                of the outer $coll that satisfies predicate `p` and
      ***REMOVED***                concatenating the results.
      ***REMOVED***
      ***REMOVED***  @usecase def flatMap[B](f: A => TraversableOnce[B]): $Coll[B]
      ***REMOVED*** 
      ***REMOVED***  @return       a new $coll resulting from applying the given collection-valued function
      ***REMOVED***                `f` to each element of the outer $coll that satisfies predicate `p` and concatenating the results.
     ***REMOVED*****REMOVED***
      def flatMap[B, That](f: A => GenTraversableOnce[B])(implicit bf: CanBuildFrom[Repr, B, That]): That = {
        val b = bf(repr)
        for (x <- self) 
          if (p(x)) b ++= f(x).seq
        b.result
      }

     ***REMOVED*****REMOVED*** Applies a function `f` to all elements of the outer $coll containing
      ***REMOVED***  this `WithFilter` instance that satisfy predicate `p`.
      ***REMOVED***
      ***REMOVED***  @param  f   the function that is applied for its side-effect to every element.
      ***REMOVED***              The result of function `f` is discarded.
      ***REMOVED***              
      ***REMOVED***  @tparam  U  the type parameter describing the result of function `f`. 
      ***REMOVED***              This result will always be ignored. Typically `U` is `Unit`,
      ***REMOVED***              but this is not necessary.
      ***REMOVED***
      ***REMOVED***  @usecase def foreach(f: A => Unit): Unit
     ***REMOVED*****REMOVED***   
      def foreach[U](f: A => U): Unit = 
        for (x <- self) 
          if (p(x)) f(x)

     ***REMOVED*****REMOVED*** Further refines the filter for this $coll.
      ***REMOVED***
      ***REMOVED***  @param q   the predicate used to test elements.
      ***REMOVED***  @return    an object of class `WithFilter`, which supports
      ***REMOVED***             `map`, `flatMap`, `foreach`, and `withFilter` operations.
      ***REMOVED***             All these operations apply to those elements of this $coll which
      ***REMOVED***             satisfy the predicate `q` in addition to the predicate `p`.
     ***REMOVED*****REMOVED***
      def withFilter(q: A => Boolean): WithFilter = 
        new WithFilter(x => p(x) && q(x))
    }

    // A helper for tails and inits.
    private def iterateUntilEmpty(f: Traversable[A @uV] => Traversable[A @uV]): Iterator[Repr] = {
      val it = Iterator.iterate(thisCollection)(f) takeWhile (x => !x.isEmpty)
      it ++ Iterator(Nil) map (newBuilder ++= _ result)
    }
  }


</textarea>
</form>

    <script>
      var editor = CodeMirror.fromTextArea(document.getElementById("code"), {
        lineNumbers: true,
        matchBrackets: true,
        theme: "ambiance",
        mode: "text/x-scala"
      });
    </script>
  </article>
